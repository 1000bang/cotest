package com.codingtest;

/**
 * =============================================================================
 * 1. 문제 (사칙연산)
 * =============================================================================
 * 더하기(+)는 결합법칙이 성립하지만, 빼기(-)는 결합법칙이 성립하지 않습니다.
 * 예) 1 - 5 - 3 → ((1-5)-3) = -7 / (1-(5-3)) = -1
 *
 * 문자열 형태의 숫자와 "+", "-"가 들어있는 배열 arr가 주어질 때,
 * 서로 다른 연산순서의 계산 결과 중 최댓값을 return 하세요.
 *
 * [제한사항]
 * - arr 길이: 3 이상 201 이하 (항상 홀수)
 * - 숫자 개수: 2개 이상 101개 이하
 * - 숫자: 1 이상 1,000 이하 자연수 (문자열)
 * - 숫자와 연산자가 번갈아 등장
 *
 * =============================================================================
 * 2. 예시 입·출력
 * =============================================================================
 * | arr                                        | result |
 * |--------------------------------------------|--------|
 * | ["1","-","3","+","5","-","8"]               | 1      |
 * | ["5","-","3","+","1","+","2","-","4"]       | 3      |
 *
 * =============================================================================
 * 3. 핵심 아이디어: 구간 DP (Interval DP)
 * =============================================================================
 *
 * 이 문제는 "괄호를 어디에 치느냐"에 따라 결과가 달라지는 문제입니다.
 * → 모든 괄호 조합을 시도해야 하므로 "구간 DP"를 사용합니다.
 *
 * ▶ 구간 DP란?
 *   - 연속된 구간 [i, j]에 대한 최적값을 저장하는 DP
 *   - 작은 구간부터 점점 큰 구간으로 확장해 나감
 *   - 구간을 쪼개는 모든 분할점 k를 시도
 *
 * ▶ 왜 최대/최소 둘 다 필요한가?
 *   - '+' 연산: 최대 = 최대 + 최대
 *   - '-' 연산: 최대 = 최대 - 최소  ← 빼기에서 최대를 만들려면 "최소"를 빼야!
 *   - 따라서 dp_max와 dp_min 테이블이 모두 필요합니다.
 *
 * ▶ DP 정의:
 *   - dp_max[i][j] = 숫자 i번째~j번째를 사용한 식의 최댓값
 *   - dp_min[i][j] = 숫자 i번째~j번째를 사용한 식의 최솟값
 *
 * ▶ 점화식 (분할점 k로 [i,k]와 [k+1,j]로 쪼갬):
 *   - '+' 연산자:
 *     dp_max[i][j] = max( dp_max[i][k] + dp_max[k+1][j] )
 *     dp_min[i][j] = min( dp_min[i][k] + dp_min[k+1][j] )
 *   - '-' 연산자:
 *     dp_max[i][j] = max( dp_max[i][k] - dp_min[k+1][j] )  ← 최대에서 최소를 빼야 최대!
 *     dp_min[i][j] = min( dp_min[i][k] - dp_max[k+1][j] )  ← 최소에서 최대를 빼야 최소!
 */
public class dp_level2_02 {

    public int solution(String[] arr) {
        // ============================================================
        // Step 1: 숫자와 연산자 분리
        // arr = ["1", "-", "3", "+", "5", "-", "8"]
        //   숫자:   [1, 3, 5, 8]       → 인덱스 0, 1, 2, 3
        //   연산자: ["-", "+", "-"]     → 인덱스 0, 1, 2
        //   연산자[k]는 숫자[k]와 숫자[k+1] 사이에 위치
        // ============================================================
        int numCount = (arr.length + 1) / 2;  // 숫자 개수
        int[] nums = new int[numCount];
        String[] ops = new String[numCount - 1];

        for (int i = 0; i < arr.length; i++) {
            if (i % 2 == 0) {
                nums[i / 2] = Integer.parseInt(arr[i]);  // 짝수 인덱스 → 숫자
            } else {
                ops[i / 2] = arr[i];                      // 홀수 인덱스 → 연산자
            }
        }

        // ============================================================
        // Step 2: DP 테이블 초기화
        //
        // dpMax[i][j] = 숫자 i~j 구간에서 만들 수 있는 최댓값
        // dpMin[i][j] = 숫자 i~j 구간에서 만들 수 있는 최솟값
        //
        // 기저 조건: dpMax[i][i] = dpMin[i][i] = nums[i]
        // ============================================================
        int[][] dpMax = new int[numCount][numCount];
        int[][] dpMin = new int[numCount][numCount];

        // 충분히 작은/큰 값으로 초기화
        for (int i = 0; i < numCount; i++) {
            for (int j = 0; j < numCount; j++) {
                dpMax[i][j] = Integer.MIN_VALUE;
                dpMin[i][j] = Integer.MAX_VALUE;
            }
        }

        // 기저: 숫자 하나짜리 구간
        for (int i = 0; i < numCount; i++) {
            dpMax[i][i] = nums[i];
            dpMin[i][i] = nums[i];
        }

        // ============================================================
        // Step 3: 구간 길이를 늘려가며 DP 채우기
        //
        // 트레이스 예시: ["1", "-", "3", "+", "5", "-", "8"]
        // nums = [1, 3, 5, 8], ops = ["-", "+", "-"]
        //
        // 길이 1 (기저):
        //   max[0][0]=1, max[1][1]=3, max[2][2]=5, max[3][3]=8
        //   min[0][0]=1, min[1][1]=3, min[2][2]=5, min[3][3]=8
        //
        // 길이 2:
        //   [0,1] ops[0]='-': max=1-3=-2, min=1-3=-2
        //   [1,2] ops[1]='+': max=3+5=8,  min=3+5=8
        //   [2,3] ops[2]='-': max=5-8=-3, min=5-8=-3
        //
        // 길이 3:
        //   [0,2] k=0('-'): max=1-8=-7, min=1-(-2)=3  ← 잠깐! min=1-8=-7
        //         k=1('+'): max=-2+5=3, min=-2+5=3  ← 아 여기가 핵심!
        //         → max=3, min=-7
        //   [1,3] k=1('+'): max=3+(-3)=0, min=3+(-3)=0
        //         k=2('-'): max=8-8=0,    min=8-8=0
        //         → max=0, min=0
        //
        // 길이 4 (전체):
        //   [0,3] k=0('-'): max=1-0=1,    min=1-0=1
        //         k=1('+'): max=-2+(-3)=-5
        //         k=2('-'): max=3-8=-5
        //         → max=1  ← 정답!
        // ============================================================
        for (int len = 2; len <= numCount; len++) {         // 구간 길이 (숫자 개수)
            for (int i = 0; i <= numCount - len; i++) {     // 시작 인덱스
                int j = i + len - 1;                         // 끝 인덱스

                // 분할점 k: [i, k] ops[k] [k+1, j]
                for (int k = i; k < j; k++) {
                    if (ops[k].equals("+")) {
                        // 더하기: 큰+큰=최대, 작은+작은=최소
                        dpMax[i][j] = Math.max(dpMax[i][j], dpMax[i][k] + dpMax[k + 1][j]);
                        dpMin[i][j] = Math.min(dpMin[i][j], dpMin[i][k] + dpMin[k + 1][j]);
                    } else {
                        // 빼기: 큰-작은=최대, 작은-큰=최소
                        dpMax[i][j] = Math.max(dpMax[i][j], dpMax[i][k] - dpMin[k + 1][j]);
                        dpMin[i][j] = Math.min(dpMin[i][j], dpMin[i][k] - dpMax[k + 1][j]);
                    }
                }
            }
        }

        // 전체 구간 [0, numCount-1]의 최댓값이 정답
        return dpMax[0][numCount - 1];
    }
}
