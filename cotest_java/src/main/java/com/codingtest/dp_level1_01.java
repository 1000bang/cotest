package com.codingtest;

import java.util.*;

/**
 * =============================================================================
 * 1. 문제 (N으로 표현)
 * =============================================================================
 * 아래와 같이 5와 사칙연산만으로 12를 표현할 수 있습니다.
 *
 * 12 = 5 + 5 + (5 / 5) + (5 / 5)
 * 12 = 55 / 5 + 5 / 5
 * 12 = (55 + 5) / 5
 *
 * 5를 사용한 횟수는 각각 6,5,4 입니다. 그리고 이중 가장 작은 경우는 4입니다.
 * 이처럼 숫자 N과 number가 주어질 때, N과 사칙연산만 사용해서
 * 표현할 수 있는 방법 중 N 사용횟수의 최솟값을 return 하도록
 * solution 함수를 작성하세요.
 *
 * [제한사항]
 * - N은 1 이상 9 이하입니다.
 * - number는 1 이상 32,000 이하입니다.
 * - 수식에는 괄호와 사칙연산만 가능하며 나누기 연산에서 나머지는 무시합니다.
 * - 최솟값이 8보다 크면 -1을 return 합니다.
 *
 * =============================================================================
 * 2. 예시 입·출력
 * =============================================================================
 * | N | number | return |
 * |---|--------|--------|
 * | 5 | 12     | 4      |
 * | 2 | 11     | 3      |
 *
 * 예제 #1: 문제에 나온 예와 같습니다.
 * 예제 #2: 11 = 22 / 2와 같이 2를 3번만 사용하여 표현할 수 있습니다.
 *
 * =============================================================================
 * 3. 방향을 어떻게 잡아야 할지 고민
 * =============================================================================
 * - DP (동적 프로그래밍) 접근
 * - dp[i] = N을 i번 사용해서 만들 수 있는 모든 수의 집합
 * - dp[1] = {N}, dp[2] = {NN, N+N, N-N, N*N, N/N}
 * - dp[i] = dp[j]와 dp[i-j]의 사칙연산 조합 (j=1~i-1) + N을 i번 이어붙인 수(예: 55, 555)
 * - dp[1]부터 dp[8]까지 계산하면서 number가 포함되면 그 i를 반환
 */
public class dp_level1_01 {

    public int solution(int N, int number) {
        // ============================================================
        // DP 핵심 개념: "작은 문제의 답을 저장해두고, 큰 문제를 풀 때 재활용"
        //
        // dp[i] = N을 정확히 i번 사용해서 만들 수 있는 모든 수의 집합(Set)
        //
        // 예시 (N=5):
        //   dp[1] = {5}                          ← 5 한 번으로 만들 수 있는 수
        //   dp[2] = {55, 10, 0, 25, 1}           ← 5 두 번: 55, 5+5, 5-5, 5*5, 5/5
        //   dp[3] = dp[1](+,-,*,/)dp[2] + dp[2](+,-,*,/)dp[1] + {555}
        //         = {5}의 각 수와 {55,10,0,25,1}의 각 수를 +,-,*,/ 한 결과 전부
        //         = {555, 60, 50, 275, 11, ....} <- 5 세 번 : 555, 5+55, 5-55, 5*55, 5/55, 55+5, 55-5, 55*5, 55/5, ...
        //   dp[4] = dp[1](+,-,*,/)dp[3] + dp[2](+,-,*,/)dp[2] + dp[3](+,-,*,/)dp[1] + {5555}
        //         → 여기서 12가 발견됨! (55+5)/5 = 12  → return 4
        //
        // 왜 DP인가?
        //   dp[3]을 구할 때 dp[1], dp[2]를 "재활용"
        //   dp[4]를 구할 때 dp[1], dp[2], dp[3]을 "재활용"
        //   → 이미 구한 답을 저장(메모)해두고 다시 안 구해도 됨
        // ============================================================

        // dp[0]~dp[8]까지 빈 Set으로 초기화
        List<Set<Integer>> dp = new ArrayList<>();
        for (int i = 0; i <= 8; i++) {
            dp.add(new HashSet<>());
        }

        // i = N을 사용하는 횟수 (1번부터 8번까지)
        // 최솟값이 8보다 크면 -1을 return 하라고 했으므로 8번까지만 계산
        for (int i = 1; i <= 8; i++) {

            // [1단계] N을 i번 이어붙인 수 추가
            // i=1 → "5" → 5
            // i=2 → "55" → 55
            // i=3 → "555" → 555
            int concatenatedNumber = Integer.parseInt(String.valueOf(N).repeat(i));
            dp.get(i).add(concatenatedNumber);

            // [2단계] dp[j]와 dp[i-j]의 사칙연산 조합으로 dp[i] 채우기
            // 예: i=4일 때 → j=1: dp[1](+,-,*,/)dp[3], j=2: dp[2](+,-,*,/)dp[2], j=3: dp[3](+,-,*,/)dp[1]
            //
            // 이 부분이 DP의 핵심 = "이전에 구한 결과를 조합해서 새로운 결과를 만든다" (******* 젤중요)
            for (int j = 1; j < i; j++) {
                for (int num1 : dp.get(j)) {        // dp[j]의 모든 수
                    for (int num2 : dp.get(i - j)) { // dp[i-j]의 모든 수
                        dp.get(i).add(num1 + num2);  // 덧셈
                        dp.get(i).add(num1 - num2);  // 뺄셈
                        dp.get(i).add(num1 * num2);  // 곱셈
                        if (num2 != 0) {
                            dp.get(i).add(num1 / num2); // 나눗셈 (0으로 나누기 방지)
                        }
                    }
                }
            }

            // [3단계] i번 만에 number를 만들 수 있으면 바로 반환
            // i=1부터 순서대로 검사하므로 가장 먼저 찾은 i가 곧 최솟값
            if (dp.get(i).contains(number)) {
                return i;
            }
        }

        // 8번 이내에 못 만들면 -1
        return -1;
    }


    public int solution2(int N, int number) {
       int answer = -1;
        Set<Integer>[] setArr = new Set[9];
        int t = N;
        for(int i = 1; i < 9; i++) {
            setArr[i] = new HashSet<>();
            setArr[i].add(t);
            t = t * 10 + N;
        }
        for(int i = 1; i < 9; i++) {
            for(int j = 1; j < i; j++) {
                for(Integer a : setArr[j]) {
                    for(Integer b : setArr[i - j]) {
                        setArr[i].add(a + b);
                        setArr[i].add(a - b);
                        setArr[i].add(b - a);
                        setArr[i].add(a * b);
                        if(b != 0) {
                            setArr[i].add(a / b);
                        }
                        if(a != 0) {
                            setArr[i].add(b / a);
                        }
                    }
                }
            }
        }
        for(int i = 1; i < 9; i++) {
            if(setArr[i].contains(number)) {
                answer = i;
                break;
            }
        }
        return answer;
    }
}
