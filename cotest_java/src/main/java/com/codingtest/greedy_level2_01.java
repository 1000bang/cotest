package com.codingtest;

import java.util.ArrayList;
import java.util.List;

/**
 * Greedy Level2 - 조이스틱
 *
 * =============================================================================
 * 1. 문제
 * =============================================================================
 * 맨 처음 이름은 A로만 채워져 있고, 조이스틱으로 목표 이름 name을 만들어야 합니다.
 * ▲ 다음 알파벳 / ▼ 이전 알파벳(A에서 아래면 Z) / ◀ 커서 왼쪽(첫 위치에서 왼쪽→마지막) / ▶ 커서 오른쪽.
 * 조이스틱 조작 횟수의 최솟값을 return 하세요.
 *
 * [제한사항]
 * - name은 알파벳 대문자만, 길이 1 이상 20 이하.
 *
 * =============================================================================
 * 2. 예시 입·출력
 * =============================================================================
 * | name     | return |
 * |----------|--------|
 * | "JEROEN" | 56     |
 * | "JAN"    | 23     |
 *
 * "JAZ": ▲9번(J) + ◀1번 + ▼1번(Z) = 11.
 *
 * =============================================================================
 * 3. 방향을 어떻게 잡아야 할지 고민
 * =============================================================================
 * - (1) 상하 비용: 각 자리마다 A→목표 알파벳으로 바꾸는 최소 횟수 = min(위로, 아래로) = min(c-'A', 'Z'-c+1).
 * - (2) 좌우 비용: 바꿔야 할 위치( name[i] != 'A' )를 전부 방문하는 최소 이동 횟수. 시작은 0.
 * - 전략 후보: 오른쪽만 가기(가장 오른쪽 인덱스까지), 왼쪽만 가기(0에서 왼쪽으로 가며 방문),
 *   오른쪽 끝까지 갔다가 왼쪽으로 돌아오기. 세 경우 중 최소가 좌우 비용.
 *
 * =============================================================================
 * 4. 설명 (왜 이렇게 코드를 짰는지)
 * =============================================================================
 * - 상하: 한 번에 합산. 좌우: 바꿔야 할 인덱스 목록을 구한 뒤, 오른쪽만 / 왼쪽만 / 오른쪽 끝 후 왼쪽으로 돌아오기 비용 중 최소 사용.
 */
public class greedy_level2_01 {

    public int solution(String name) {
        int n = name.length();
        // (1) 상하 비용: 각 자리마다 min(위로, 아래로)
        int vertical = 0;
        for (int i = 0; i < n; i++) {
            char c = name.charAt(i);
            vertical += Math.min(c - 'A', 'Z' - c + 1);
        }

        // (2) 바꿔야 할 인덱스 (A가 아닌 위치)
        List<Integer> need = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            if (name.charAt(i) != 'A') need.add(i);
        }
        if (need.isEmpty()) return 0;

        int maxIdx = need.get(need.size() - 1);
        int minIdx = need.get(0);
        // 오른쪽만: 0 → maxIdx
        int rightOnly = maxIdx;
        // 왼쪽만: 0에서 왼쪽으로 가며 방문. 0 제외한 r에 대해 (n - r) 중 최대 = n - (0 제외 최소)
        int leftOnly = 0;
        for (int r : need) {
            if (r == 0) continue;
            leftOnly = Math.max(leftOnly, n - r);
        }
        // 오른쪽 끝까지 갔다가 왼쪽으로 돌아오기: (n-1) + (n-1 - minIdx)
        int rightThenLeft = 2 * (n - 1) - minIdx;

        int horizontal = Math.min(rightOnly, Math.min(leftOnly > 0 ? leftOnly : rightOnly, rightThenLeft));
        return vertical + horizontal;
    }
}
