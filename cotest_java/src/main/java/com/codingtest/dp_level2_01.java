package com.codingtest;

/**
 * =============================================================================
 * 1. 문제 (등굣길)
 * =============================================================================
 * 계속되는 폭우로 일부 지역이 물에 잠겼습니다.
 * 물에 잠기지 않은 지역을 통해 학교를 가려고 합니다.
 * 집에서 학교까지 가는 길은 m x n 크기의 격자모양으로 나타낼 수 있습니다.
 *
 * 가장 왼쪽 위(집)의 좌표는 (1, 1),
 * 가장 오른쪽 아래(학교)의 좌표는 (m, n)입니다.
 *
 * 격자의 크기 m, n과 물이 잠긴 지역의 좌표를 담은 2차원 배열 puddles이
 * 매개변수로 주어질 때, 오른쪽과 아래쪽으로만 움직여 집에서 학교까지
 * 갈 수 있는 최단경로의 개수를 1,000,000,007로 나눈 나머지를 return 하세요.
 *
 * [제한사항]
 * - 격자의 크기 m, n은 1 이상 100 이하인 자연수입니다.
 * - m과 n이 모두 1인 경우는 입력으로 주어지지 않습니다.
 * - 물에 잠긴 지역은 0개 이상 10개 이하입니다.
 * - 집과 학교가 물에 잠긴 경우는 입력으로 주어지지 않습니다.
 *
 * =============================================================================
 * 2. 예시 입·출력
 * =============================================================================
 * | m | n | puddles  | return |
 * |---|---|----------|--------|
 * | 4 | 3 | [[2, 2]] | 4      |
 *
 * =============================================================================
 * 3. 방향을 어떻게 잡아야 할지 고민
 * =============================================================================
 * - DP 접근: 각 칸까지 도달할 수 있는 경로 수를 누적
 * - dp[y][x] = (y, x)까지 올 수 있는 최단경로의 개수
 * - 이동은 오른쪽/아래쪽만 가능하므로:
 *   dp[y][x] = dp[y-1][x] (위에서 옴) + dp[y][x-1] (왼쪽에서 옴)
 * - 물에 잠긴 칸은 dp[y][x] = 0 (지나갈 수 없음)
 * - 주의: puddles의 좌표는 (x, y) = (열, 행) 순서!
 */
public class dp_level2_01 {

    public int solution(int m, int n, int[][] puddles) {
        // ============================================================
        // 핵심 아이디어: "각 칸에 도달하는 경로 수 = 위에서 온 경로 + 왼쪽에서 온 경로"
        //
        // 좌표 주의! 문제에서 (m, n) = (가로 크기, 세로 크기)
        //   m = 열(column) 수 = 가로 길이
        //   n = 행(row) 수 = 세로 길이
        //   puddles[i] = [x, y] = [열, 행]
        //
        // dp[y][x] = (y행, x열)까지 도달하는 경로 수
        //
        // 예시 트레이스 (m=4, n=3, puddle=(2,2)):
        //
        //   격자:                dp 테이블:
        //   (1,1) (2,1) (3,1) (4,1)     1  1  1  1
        //   (1,2) [2,2] (3,2) (4,2)     1  0  1  2
        //   (1,3) (2,3) (3,3) (4,3)     1  1  2  4  ← 정답: 4
        //
        //   dp[1][1] = 1 (출발점)
        //   dp[1][2] = 1, dp[1][3] = 1, dp[1][4] = 1  (첫 행: 오른쪽으로만)
        //   dp[2][1] = 1                                (첫 열: 아래로만)
        //   dp[2][2] = 0 (웅덩이!)
        //   dp[2][3] = dp[1][3] + dp[2][2] = 1 + 0 = 1
        //   dp[2][4] = dp[1][4] + dp[2][3] = 1 + 1 = 2
        //   dp[3][1] = 1
        //   dp[3][2] = dp[2][2] + dp[3][1] = 0 + 1 = 1
        //   dp[3][3] = dp[2][3] + dp[3][2] = 1 + 1 = 2
        //   dp[3][4] = dp[2][4] + dp[3][3] = 2 + 2 = 4  ← 정답!
        // ============================================================

        int MOD = 1_000_000_007;

        // dp[y][x]: y행 x열까지 도달하는 경로 수 (1-indexed 사용)
        int[][] dp = new int[n + 1][m + 1];

        // 웅덩이 표시용 배열
        boolean[][] isPuddle = new boolean[n + 1][m + 1];
        for (int[] puddle : puddles) {
            // puddle[0] = x(열), puddle[1] = y(행) ← 순서 주의!
            isPuddle[puddle[1]][puddle[0]] = true;
        }

        // 출발점: 집(1,1)에서 시작하는 경로 1개
        dp[1][1] = 1;

        // 왼쪽 위 → 오른쪽 아래 순서로 채워나감
        for (int y = 1; y <= n; y++) {
            for (int x = 1; x <= m; x++) {
                // 출발점은 이미 1로 설정됨
                if (y == 1 && x == 1) continue;

                // 웅덩이: 지나갈 수 없으므로 경로 수 = 0
                if (isPuddle[y][x]) {
                    dp[y][x] = 0;
                    continue;
                }

                // 위에서 내려온 경로 수
                int fromAbove = y > 1 ? dp[y - 1][x] : 0;
                // 왼쪽에서 온 경로 수
                int fromLeft = x > 1 ? dp[y][x - 1] : 0;

                // 두 방향의 경로 수를 합산 (MOD로 나머지)
                dp[y][x] = (fromAbove + fromLeft) % MOD;
            }
        }

        // 학교 위치(n행, m열)의 경로 수가 정답
        return dp[n][m];
    }
}
