package com.codingtest;

/**
 * =============================================================================
 * 1. 문제 (타겟 넘버)
 * =============================================================================
 * n개의 음이 아닌 정수들이 있습니다.
 * 이 정수들을 순서를 바꾸지 않고 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다.
 *
 * 예) [1, 1, 1, 1, 1]로 3을 만드는 방법:
 *   -1+1+1+1+1 = 3
 *   +1-1+1+1+1 = 3
 *   +1+1-1+1+1 = 3
 *   +1+1+1-1+1 = 3
 *   +1+1+1+1-1 = 3  → 총 5가지
 *
 * [제한사항]
 * - 숫자 개수: 2개 이상 20개 이하
 * - 각 숫자: 1 이상 50 이하 자연수
 * - 타겟 넘버: 1 이상 1000 이하 자연수
 *
 * =============================================================================
 * 2. 예시 입·출력
 * =============================================================================
 * | numbers         | target | return |
 * |-----------------|--------|--------|
 * | [1, 1, 1, 1, 1] | 3      | 5      |
 * | [4, 1, 2, 1]    | 4      | 2      |
 *
 * =============================================================================
 * 3. 핵심 아이디어: DFS (깊이 우선 탐색)
 * =============================================================================
 *
 * 각 숫자마다 "더하기(+)" 또는 "빼기(-)" 두 가지 선택지가 있습니다.
 * → 이진 트리처럼 모든 경우를 탐색하면 됩니다!
 *
 * ▶ DFS란?
 *   - 한 갈래를 끝까지 파고든 뒤, 되돌아와서 다른 갈래를 탐색하는 방법
 *   - 재귀(recursion)로 자연스럽게 구현 가능
 *
 * ▶ 이 문제에서의 DFS:
 *   - 각 숫자를 만날 때마다 "더하기/빼기" 두 갈래로 분기
 *   - 모든 숫자를 다 사용한 후 합이 target이면 count++
 *   - 총 경우의 수: 2^n (n=20이면 약 100만, 충분히 빠름)
 *
 * ▶ 탐색 트리 예시 (numbers=[4,1,2,1], target=4):
 *
 *                    0 (시작)
 *                 /        \
 *             +4              -4
 *            /   \           /   \
 *         +1      -1      +1      -1
 *        /  \    /  \    /  \    /  \
 *      +2   -2 +2  -2 +2   -2 +2   -2
 *      / \ / \ / \ / \ / \ / \ / \ / \
 *     +1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1
 *
 *   리프 노드에서 합계 확인:
 *   4+1+2+1=8 ✗  4+1+2-1=6 ✗  4+1-2+1=4 ✓  4+1-2-1=2 ✗
 *   4-1+2+1=6 ✗  4-1+2-1=4 ✓  4-1-2+1=2 ✗  4-1-2-1=0 ✗
 *   ... (-4로 시작하는 경우는 모두 ✗)
 *   → 총 2가지 = 정답!
 */
public class dfs_level2_01 {

    // ============================================================
    // 풀이 1: DFS (재귀)
    // - 가장 직관적인 풀이
    // - 각 숫자에서 +/- 두 갈래로 재귀 호출
    // ============================================================
    int count = 0;

    public int solution(int[] numbers, int target) {
        count = 0;
        dfs(numbers, target, 0, 0);
        return count;
    }

    /**
     * @param idx  현재 처리할 숫자의 인덱스
     * @param sum  지금까지의 합계
     */
    private void dfs(int[] numbers, int target, int idx, int sum) {
        // 모든 숫자를 다 사용했으면
        if (idx == numbers.length) {
            // 합이 target과 같으면 방법 하나 발견!
            if (sum == target) {
                count++;
            }
            return;
        }

        // 갈래 1: 현재 숫자를 "더하기"
        dfs(numbers, target, idx + 1, sum + numbers[idx]);
        // 갈래 2: 현재 숫자를 "빼기"
        dfs(numbers, target, idx + 1, sum - numbers[idx]);
    }

    // ============================================================
    // 풀이 2: DFS (멤버 변수 없이, return 값으로 카운트)
    // - count 전역 변수 없이 깔끔한 버전
    // - 재귀의 리턴값 = 해당 서브트리에서 찾은 경우의 수
    // ============================================================
    public int solution2(int[] numbers, int target) {
        return dfs2(numbers, target, 0, 0);
    }

    private int dfs2(int[] numbers, int target, int idx, int sum) {
        if (idx == numbers.length) {
            return sum == target ? 1 : 0;
        }
        // 더하는 경우의 수 + 빼는 경우의 수
        return dfs2(numbers, target, idx + 1, sum + numbers[idx])
             + dfs2(numbers, target, idx + 1, sum - numbers[idx]);
    }
}
