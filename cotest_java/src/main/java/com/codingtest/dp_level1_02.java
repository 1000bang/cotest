package com.codingtest;

/**
 * =============================================================================
 * 1. 문제 (정수 삼각형)
 * =============================================================================
 *            7
 *         3   8
 *       8   1   0
 *     2   7   4   4
 *   4   5   2   6   5
 *
 * 위와 같은 삼각형의 꼭대기에서 바닥까지 이어지는 경로 중,
 * 거쳐간 숫자의 합이 가장 큰 경우를 찾아보려고 합니다.
 * 아래 칸으로 이동할 때는 대각선 방향으로 한 칸 오른쪽 또는 왼쪽으로만 이동 가능합니다.
 * 예를 들어 3에서는 그 아래칸의 8 또는 1로만 이동이 가능합니다.
 *
 * 삼각형의 정보가 담긴 배열 triangle이 매개변수로 주어질 때,
 * 거쳐간 숫자의 최댓값을 return 하도록 solution 함수를 완성하세요.
 *
 * [제한사항]
 * - 삼각형의 높이는 1 이상 500 이하입니다.
 * - 삼각형을 이루고 있는 숫자는 0 이상 9,999 이하의 정수입니다.
 *
 * =============================================================================
 * 2. 예시 입·출력
 * =============================================================================
 * | triangle                                              | result |
 * |-------------------------------------------------------|--------|
 * | [[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]] | 30     |
 *
 * 7 → 3 → 8 → 7 → 5 = 30
 *
 * =============================================================================
 * 3. 방향을 어떻게 잡아야 할지 고민
 * =============================================================================
 * - DP 접근: 아래에서 위로 올라가면서 최댓값을 누적
 * - dp[i][j] = i행 j열까지 올 수 있는 최대 합
 * - 아래 행에서 왼쪽 자식, 오른쪽 자식 중 큰 값을 현재 값에 더함
 * - 바닥에서 시작해서 꼭대기에 도착하면 dp[0][0]이 정답
 *
 * 예시 트레이스 (아래→위):
 *   바닥:    4   5   2   6   5
 *   4행→3행: 2+5=7  7+7=14  4+6=10  4+6=10
 *          → [7, 14, 10, 10]
 *   3행→2행: 8+14=22  1+14=15  0+10=10
 *          → [22, 15, 10]
 *   2행→1행: 3+22=25  8+15=23
 *          → [25, 23]
 *   1행→0행: 7+25=32? → 아, 7+25=32가 아니라...
 *
 *   실제로는 max를 선택하므로:
 *   dp[0][0] = 7 + max(25, 23) = 7 + 25 = 32? ← 경로: 7→3→8→7→5=30인데?
 *
 *   ※ 위에서 아래로 접근하면:
 *   dp[i][j] = triangle[i][j] + max(dp[i-1][j-1], dp[i-1][j])
 *   이 방식이 더 직관적
 */
public class dp_level1_02 {

    public int solution(int[][] triangle) {
        // ============================================================
        // 핵심 아이디어: "위에서 아래로 내려가면서 최대 합을 누적"
        //
        // triangle 자체를 dp 테이블로 사용 (별도 배열 불필요)
        // triangle[i][j] += max(위 왼쪽, 위 오른쪽)
        //
        // 삼각형 구조에서 [i][j]에 올 수 있는 곳:
        //   - 왼쪽 위: [i-1][j-1]  (j > 0일 때만)
        //   - 오른쪽 위: [i-1][j]  (j < i일 때만)
        //
        // 예시 트레이스:
        //
        // 원본:          누적 후:
        //      7              7
        //    3   8         10   15        ← 3+7=10, 8+7=15
        //   8  1  0       18  16  15      ← 8+10=18, max(10,15)+1=16, 0+15=15
        //  2  7  4  4    20  25  20  19   ← 2+18=20, max(18,16)+7=25, max(16,15)+4=20, 4+15=19
        // 4  5  2  6  5  24  30  27  26  24 ← ... 바닥 행에서 최대값 = 30
        // ============================================================

        // i=1행부터 시작 (0행은 꼭대기, 그대로 사용)
        for (int i = 1; i < triangle.length; i++) {
            for (int j = 0; j < triangle[i].length; j++) {

                // 맨 왼쪽 (j=0): 올 수 있는 곳은 바로 위 [i-1][0] 뿐
                if (j == 0) {
                    triangle[i][j] += triangle[i - 1][j];
                }
                // 맨 오른쪽 (j=i): 올 수 있는 곳은 바로 위 [i-1][j-1] 뿐
                else if (j == i) {
                    triangle[i][j] += triangle[i - 1][j - 1];
                }
                // 중간: 왼쪽 위, 오른쪽 위 중 큰 값을 더함
                else {
                    triangle[i][j] += Math.max(triangle[i - 1][j - 1], triangle[i - 1][j]);
                }
            }
        }

        // 바닥 행에서 최대값이 정답
        int max = 0;
        int lastRow = triangle.length - 1;
        for (int val : triangle[lastRow]) {
            max = Math.max(max, val);
        }
        return max;
    }
}
