package com.codingtest;

/**
 * Brute-Force Level1 - 최소 지갑 크기 (명함 지갑)
 *
 * =============================================================================
 * 1. 문제
 * =============================================================================
 * 다양한 명함을 모두 수납할 수 있으면서 가장 작은 지갑의 크기를 구합니다.
 * 명함의 가로·세로 길이가 담긴 2차원 배열 sizes가 주어질 때,
 * 모든 명함을 수납할 수 있는 가장 작은 지갑의 크기(가로×세로)를 return 하세요.
 * 명함은 90도 회전(가로↔세로 뒤집기)하여 수납할 수 있습니다.
 *
 * [제한사항]
 * - sizes의 길이는 1 이상 10,000 이하.
 * - sizes[i]는 [w, h] 형식, w·h는 1 이상 1,000 이하 자연수.
 *
 * =============================================================================
 * 2. 예시 입·출력
 * =============================================================================
 * | sizes                                              | result |
 * |----------------------------------------------------|--------|
 * | [[60,50],[30,70],[60,30],[80,40]]                  | 4000   |
 * | [[10,7],[12,3],[8,15],[14,7],[5,15]]               | 120    |
 * | [[14,4],[19,6],[6,16],[18,7],[7,11]]               | 133    |
 *
 * =============================================================================
 * 3. 방향을 어떻게 잡아야 할지 고민
 * =============================================================================
 * - 지갑이 모든 명함을 담으려면: 지갑의 가로 ≥ 각 명함의 가로, 지갑의 세로 ≥ 각 명함의 세로.
 * - 명함을 회전할 수 있으므로, 각 명함은 (w,h) 또는 (h,w) 중 하나로 배치 가능.
 * - "최소 지갑"을 만들려면: 한 축에는 가능한 한 작은 값만 필요하게 해야 함.
 * - 통일된 전략: 모든 명함에서 "긴 변"을 한 축에, "짧은 변"을 다른 축에 배치한다고 가정.
 *   그러면 지갑 가로 = max(긴 변들), 지갑 세로 = max(짧은 변들)이 되고, 이때 넓이가 최소가 됨.
 * - 따라서 명함마다 longer = max(w,h), shorter = min(w,h)를 구한 뒤,
 *   maxLong = max(longer들), maxShort = max(shorter들) → 답 = maxLong * maxShort.
 *
 * =============================================================================
 * 4. 설명 (왜 이렇게 코드를 짰는지)
 * =============================================================================
 * - 각 명함 [w, h]에 대해 Math.max(w,h), Math.min(w,h)로 "회전을 반영한" 긴 변·짧은 변을 구합니다.
 * - 이렇게 하면 "뒤집었을 때의 최선"이 자동으로 반영되므로, 별도로 경우를 나눌 필요가 없습니다.
 * - for 문으로 한 번 순회하며 maxLong, maxShort만 갱신하고, 마지막에 곱해서 반환합니다.
 * - 한 번의 순회로 해결되므로 시간 O(n), 추가 공간 O(1)입니다.
 */
public class BruteForce_level1_01 {

    public int solution(int[][] sizes) {
        int maxLong = 0;  // 각 명함의 "긴 변" 중 최대
        int maxShort = 0; // 각 명함의 "짧은 변" 중 최대

        for (int i = 0; i < sizes.length; i++) {
            int w = sizes[i][0];
            int h = sizes[i][1];
            // 뒤집기 = 둘 중 긴 쪽/짧은 쪽으로 통일
            int longer = Math.max(w, h);
            int shorter = Math.min(w, h);

            if (maxLong < longer) maxLong = longer;
            if (maxShort < shorter) maxShort = shorter;
        }

        return maxLong * maxShort;
    }
}
