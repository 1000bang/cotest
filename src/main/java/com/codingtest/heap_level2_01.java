package com.codingtest;

import java.util.Arrays;
import java.util.PriorityQueue;
/**
 * =============================================================================
 * 1. 문제 (디스크 컨트롤러)
 * =============================================================================
 * 하드디스크는 한 번에 하나의 작업만 수행할 수 있습니다.
 * 우선순위 디스크 컨트롤러는 다음과 같이 동작합니다.
 *
 * - 어떤 작업 요청이 들어오면 [작업 번호, 요청 시각, 소요 시간]을 대기 큐에 저장합니다. (처음 큐는 비어 있음)
 * - 하드디스크가 쉬고 있고 대기 큐가 비어있지 않으면, 우선순위가 높은 작업을 큐에서 꺼내 실행합니다.
 *   우선순위: (1) 소요시간 짧은 것 (2) 요청 시각 빠른 것 (3) 작업 번호 작은 것
 * - 한 번 시작한 작업은 끝날 때까지 그 작업만 수행합니다.
 * - 작업 완료 시점과 새 요청 시점이 겹치면: 완료 → 새 요청을 큐에 넣음 → 큐에서 우선순위 높은 작업을 꺼내 실행.
 *
 * 반환 시간(turnaround time) = 작업 요청 시점부터 종료 시점까지 걸린 시간.
 * 모든 작업의 반환 시간의 평균의 정수부분을 return 하세요.
 *
 * [제한사항]
 * - 1 ≤ jobs의 길이 ≤ 500
 * - jobs[i] = [s, l] : s = 요청 시점 (0 ≤ s ≤ 1,000), l = 소요시간 (1 ≤ l ≤ 1,000)
 *
 * =============================================================================
 * 2. 예시 입·출력
 * =============================================================================
 * | jobs                    | return |
 * |-------------------------|--------|
 * | [[0, 3], [1, 9], [3, 5]]| 8      |
 *
 * 예시 처리 흐름:
 * - 0ms: 0번 [0ms, 3ms] 요청 → 큐에 넣음 → 0번 시작 (0~3ms)
 * - 1ms: 1번 [1ms, 9ms] 요청 → 큐에 넣음
 * - 3ms: 0번 완료, 2번 [3ms, 5ms] 요청 → 큐에 2번 넣음 → 소요시간 짧은 2번 선택 → 2번 시작 (3~8ms)
 * - 8ms: 2번 완료 → 1번 시작 (8~17ms)
 * - 17ms: 1번 완료
 * 반환 시간: 0번 3ms, 1번 16ms, 2번 5ms → 평균 (3+16+5)/3 = 8
 *
 * =============================================================================
 * 3. 방향을 어떻게 잡아야 할지 고민
 * =============================================================================
 * - 우선순위는 "이미 요청이 들어온 작업"에게만 적용한다. [20, 1]은 요청 시각이 20이므로,
 *   현재 시각이 20이 되기 전에는 대기 큐에 아예 넣지 않는다. 그래서 소요시간이 1이라도 20ms 전에는 후보가 아님.
 *
 * - 흐름: "현재 시각(now)"을 두고,
 *   (1) 요청 시각 ≤ now 인 작업만 우선순위 큐(대기 큐)에 넣는다.
 *   (2) 큐에서 우선순위대로 하나 꺼내서 실행 → now += 소요시간, 반환시간 누적.
 *   (3) 큐가 비었는데 아직 안 들어온 작업이 있으면, now를 "다음 요청 시각"으로 넘긴 뒤 (1)부터.
 *
 * - jobs를 요청 시각 순으로 정렬해 두면, "지금 시각까지 들어온 요청"을 순서대로 큐에 넣기 쉽다.
 * - 큐의 우선순위: (소요시간 짧은 것 → 요청 시각 빠른 것 → 번호 작은 것). Comparator로 지정.
 *
 * =============================================================================
 * 4. 설명 (왜 이렇게 코드를 짰는지)
 * =============================================================================
 * - 요청 시각 순 정렬된 배열 + "현재 시각까지 들어온 작업"만 넣는 우선순위 큐(소요시간→요청시각→번호).
 * - now를 두고, 매번 now 이하로 요청된 작업을 큐에 넣고, 큐에서 하나 꺼내 실행 후 now 갱신·반환시간 누적.
 * - 큐가 비었으면 now를 다음 요청 시각으로 점프. 최종 total/n 반환.
 */
public class heap_level2_01 {

    /**
     * @param jobs 각 원소 [요청 시점, 소요시간]
     * @return 모든 작업의 반환 시간 평균의 정수부분
     */
    public int solution(int[][] jobs) {
        int n = jobs.length;

        // ----- ① 요청 시각 순으로 정렬할 배열 만들기 -----
        // 정렬하면 원래 인덱스(작업 번호)가 사라지므로 [요청시각, 소요시간, 원래번호] 3칸으로 저장
        int[][] arr = new int[n][3];
        for (int i = 0; i < n; i++) {
            arr[i][0] = jobs[i][0];   // 요청 시각
            arr[i][1] = jobs[i][1];   // 소요 시간
            arr[i][2] = i;            // 원래 작업 번호 (우선순위 3번째에 사용)
        }
        Arrays.sort(arr, (a, b) -> a[0] - b[0]);  // 요청 시각 오름차순 → "지금 시각까지 들어온 요청"을 idx로 순서대로 넣기 위함

        // ----- ② 대기 큐 (우선순위: 소요시간 → 요청시각 → 번호) -----
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {
            if (a[1] != b[1]) return a[1] - b[1];  // 1순위: 소요시간 짧은 것
            if (a[0] != b[0]) return a[0] - b[0];  // 2순위: 요청 시각 빠른 것
            return a[2] - b[2];                     // 3순위: 작업 번호 작은 것
        });

        int now = 0;    // 현재 시각 (디스크가 다음 작업을 시작할 수 있는 시점)
        int idx = 0;    // arr에서 아직 큐에 안 넣은 작업 중 가장 앞 인덱스
        int total = 0;  // 모든 작업의 반환 시간 합

        // ----- ③ 모든 작업을 처리할 때까지 반복 -----
        while (idx < n || !pq.isEmpty()) {

            // ③-1. 요청 시각이 now 이하인 작업은 "이미 들어온 요청" → 전부 큐에 넣기
            while (idx < n && arr[idx][0] <= now) {
                pq.offer(arr[idx]);
                idx++;
            }

            // ③-2. 큐가 비었음 = 지금 시각에 들어온 요청이 없음 → now를 "다음 요청 시각"으로 점프
            if (pq.isEmpty()) {
                now = arr[idx][0];
                continue;
            }

            // ③-3. 큐에서 우선순위 가장 높은 작업 하나 꺼내서 실행
            int[] job = pq.poll();
            // 반환시간 = (작업 시작 시각 - 요청 시각) + 소요시간 = 대기시간 + 소요시간
            total += (now - job[0] + job[1]);
            now += job[1];  // 이 작업이 끝나는 시각 = 다음 작업을 시작할 수 있는 시각
        }

        return total / n;  // 평균의 정수부분
    }
}
