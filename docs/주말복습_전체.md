# 주말 복습 – 전체 (Brute Force / Hash / Heap / Queue / Sort / Stack)

**진행:** 토요일에 문제만 보고 풀어 보기 → **일요일에 "정답 확인" 섹션**을 열어서 비교하기.

---

## 1. 복습할 문제 목록 (먼저 풀어 보기)

### Brute Force

| 번호 | 클래스 | 한 줄 요약 | 예시 |
|------|--------|------------|------|
| A1 | BruteForce_level1_01 | 명함 전부 수납하는 **최소 지갑** 넓이 (명함 회전 가능) | `[[60,50],[30,70],[60,30],[80,40]]` → 4000 |
| A2 | BruteForce_level1_02 | 수포자 3명 패턴으로 찍을 때 **가장 많이 맞힌 사람** 오름차순 | `[1,3,2,4,2]` → [1,2,3] |
| A3 | BruteForce_level2_01 | 종이 조각으로 만든 숫자 중 **소수 개수** (011=11) | `"011"` → 2 |

```java
//A1

//A2


//A3
```

### Hash

| 번호 | 클래스 | 한 줄 요약 | 예시 |
|------|--------|------------|------|
| B1 | hash_level1_01 | **완주하지 못한 선수** 이름 (동명이인 가능) | participant/completion → "leo" |
| B2 | hash_level1_02 | N/2마리 선택 시 **최대한 다양한 폰켓몬 종류** 개수 | [3,1,2,3] → 2 |
| B3 | hash_level2_01 | 전화번호 중 **한 번호가 다른 번호의 접두어**인지 | ["119","97674223","1195524421"] → false |
| B4 | hash_level2_02 | **서로 다른 옷 조합** 개수 (종류별 최대 1개, 최소 1개 착용) | clothes → 5 |

```java
// B1

//B2

// B3
```

### Heap

| 번호 | 클래스 | 한 줄 요약 | 예시 |
|------|--------|------------|------|
| C1 | heap_level1_01 | 스코빌 **K 이상** 만들기 위해 **섞는 최소 횟수** (가장 작은 2개 섞기) | scoville, K=7 → 2 |
| C2 | heap_level2_01 | **디스크 컨트롤러** – 반환 시간 평균의 정수 (소요시간 짧은 것 우선) | [[0,3],[1,9],[3,5]] → 8 |

````java
//C1

//C2
````

### Queue

| 번호 | 클래스 | 한 줄 요약 | 예시 |
|------|--------|------------|------|
| D1 | queue_level1_01 | **기능개발** – 배포 순서대로 각 배포마다 몇 개씩 배포되는지 | [93,30,55], [1,30,5] → [2,1] |

```java
// D1
```

### Sort

| 번호 | 클래스 | 한 줄 요약 | 예시 |
|------|--------|------------|------|
| E1 | sort_level1_01 | **K번째 수** – array의 i~j 구간 정렬 후 k번째 수 | array, commands → [5,6,3] |
| E2 | sort_level2_01 | **가장 큰 수** – 이어 붙여 만든 가장 큰 수 (문자열) | [6,10,2] → "6210" |

```java
//E1

//E2

```

### Stack

| 번호 | 클래스 | 한 줄 요약 | 예시 |
|------|--------|------------|------|
| F1 | stack_level1_01 | **연속 중복 제거** – 같은 숫자 연속이면 하나만 남기기 | [1,1,3,3,0,1,1] → [1,3,0,1] |
| F2 | stack_level2_01 | **올바른 괄호** – '(' ')' 짝이 맞으면 true | "()()" → true |

```java
//F1

//F2
```





---

## 2. 풀이 방향 (막히면 참고)

<details>
<summary>▶ Brute Force 힌트</summary>
  - **A1:** 각 명함에서 긴 변 = max(w,h), 짧은 변 = min(w,h). 지갑 = max(긴 변들) × max(짧은 변들).  
  - **A2:** i번 문제의 답 = pattern[i % 패턴길이]. 맞힌 개수 세고 최댓값과 같은 사람만 1,2,3 순으로.  
  - **A3:** 순열 백트래킹(used, path) → Set에 숫자 수집. 2 이상만 소수 판별(2~√n) 후 개수.
  </details>


<details>
<summary>▶ Hash 힌트</summary>
- **B1:** 이름 → 카운트. participant +1, completion -1. 카운트≠0인 이름이 미완주자.  
- **B2:** 서로 다른 종류 수 = Set 크기. 정답 = min(종류 수, N/2).  
- **B3:** 정렬 후 인접만 비교: 뒤가 앞으로 시작하면 false. 또는 Set에 넣고 각 번호의 접두사가 Set에 있는지.  
- **B4:** 종류별 개수 세기. (각 종류별 count+1) 곱한 뒤 -1 (아무것도 안 입는 경우 제외).
</details>

<details>
<summary>▶ Heap 힌트</summary>
- **C1:** 최소 힙에 전부 넣기. poll 2개 꺼내서 섞고 결과 offer. peek()≥K 될 때까지. 1개 남았는데 K 미만이면 -1.  
- **C2:** jobs 요청 시각 순 정렬. 현재 시각(now)까지 들어온 작업만 PQ(소요시간 짧은 순)에 넣고, 하나 꺼내 실행 → now 갱신, 반환시간 누적. 큐 비면 now를 다음 요청 시각으로.
</details>

<details>
<summary>▶ Queue 힌트</summary>
- **D1:** 각 기능 완료 일수 = ceil((100-progress)/speed). 순서대로 “오늘 배포일” 이하인 연속된 개수만큼 묶어서 카운트.
</details>

<details>
<summary>▶ Sort 힌트</summary>
- **E1:** copyOfRange(array, i-1, j) 후 정렬, [k-1] 반환. (i,j,k는 1부터)  
- **E2:** 문자열로 바꾼 뒤 (b+a).compareTo(a+b) 정렬. 이어 붙인 문자열 반환. 전부 0이면 "0".
</details>

<details>
<summary>▶ Stack 힌트</summary>
- **F1:** i==0 또는 arr[i]!=arr[i-1] 일 때만 결과에 추가.  
- **F2:** '('면 push, ')'면 pop. pop할 게 없으면 false. 끝나고 스택 비어 있어야 true.
</details>

---

## 3. 정답 코드 위치

| 문제 | 클래스 | 메서드 |
|------|--------|--------|
| A1~A3 | BruteForce_level1_01, 02, level2_01 | solution |
| B1~B4 | hash_level1_01, 02, level2_01, level2_02 | solution |
| C1~C2 | heap_level1_01, level2_01 | solution (heap은 solution2가 Heap 버전) |
| D1 | queue_level1_01 | solution |
| E1~E2 | sort_level1_01, level2_01 | solution |
| F1~F2 | stack_level1_01, level2_01 | solution |

테스트: `*Test` 클래스에서 예제 검증 가능.

---

## 4. 정답 확인 (일요일에 보기)

<details>
<summary>🔒 A1 명함 지갑</summary>
`longer = max(w,h)`, `shorter = min(w,h)` → `maxLong`, `maxShort` 갱신 → `return maxLong * maxShort;`
</details>

<details>
<summary>🔒 A2 수포자</summary>
패턴 3개 배열, `answers[i]`와 `pattern[i % len]` 비교해 c1,c2,c3. max와 같은 사람만 1,2,3 순으로 리스트에 넣어 반환.
</details>

<details>
<summary>🔒 A3 소수 찾기</summary>
`Set` + `used[]` + `StringBuilder path` 백트래킹. path 비어 있지 않을 때마다 parseInt 해서 Set에 추가. 2 이상만 isPrime(2~√n)으로 세기.
</details>

<details>
<summary>🔒 B1 완주하지 못한 선수</summary>
HashMap 이름→카운트. participant에서 +1, completion에서 -1. 카운트≠0인 키 반환.
</details>

<details>
<summary>🔒 B2 폰켓몬</summary>
HashSet에 nums 넣어 종류 수 구함. `return Math.min(set.size(), nums.length/2);`
</details>

<details>
<summary>🔒 B3 전화번호 접두어</summary>
정렬 후 for i: `phone_book[i+1].startsWith(phone_book[i])` 이면 false. 끝까지 없으면 true.
</details>

<details>
<summary>🔒 B4 의상</summary>
종류별 개수 map. answer=1부터 각 (count+1) 곱함. `return answer - 1;`
</details>

<details>
<summary>🔒 C1 더 맵게</summary>
PriorityQueue(최소 힙)에 scoville 넣기. poll 2개 → 섞은 값 offer, 횟수+1. peek()≥K면 종료. 1개 남았는데 K 미만이면 -1.
</details>

<details>
<summary>🔒 C2 디스크 컨트롤러</summary>
jobs 요청 시각 순 정렬. now 두고, now 이하 요청만 PQ(소요시간 순)에 넣고 poll 한 개 실행 → now += 소요시간, 반환시간 누적. 큐 비면 now를 다음 요청 시각으로. 평균의 정수 반환.
</details>

<details>
<summary>🔒 D1 기능개발</summary>
남은 일수 = (100-p+s-1)/s (올림). 순서대로 releaseDay 정하고, 그 이하인 연속 개수만큼 리스트에 추가 후 인덱스 점프.
</details>

<details>
<summary>🔒 E1 K번째 수</summary>
command마다 copyOfRange(array, cmd[0]-1, cmd[1]) 정렬 후 [cmd[2]-1] 을 answer에.
</details>

<details>
<summary>🔒 E2 가장 큰 수</summary>
숫자→문자열, (a,b)->(b+a).compareTo(a+b) 정렬 후 이어 붙이기. 맨 앞 "0"이면 "0" 반환.
</details>

<details>
<summary>🔒 F1 연속 중복 제거</summary>
i==0 또는 arr[i]!=arr[i-1] 일 때만 list.add. list를 int[]로 반환.
</details>

<details>
<summary>🔒 F2 올바른 괄호</summary>
'(' → push, ')' → 비어 있으면 false, 아니면 pop. 끝나고 스택 비어 있으면 true.
</details>

---

**마무리:** 1번에서 문제만 보고 풀어 본 뒤, 일요일에 4번을 펼쳐서 로직을 비교하면 됩니다.
